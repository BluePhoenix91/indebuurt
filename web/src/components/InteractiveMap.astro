---
interface Marker {
  lat: number;
  lon: number;
  name: string;
  number?: number;
}

interface Props {
  center: {
    lat: number;
    lon: number;
    zoom: number;
  };
  markers?: Marker[];
  className?: string;
  height?: string;
  markerColor?: string;
}

const { center, markers = [], className = "", height = "100%", markerColor = "#ff7a70" } = Astro.props;
const mapId = `map-${Math.random().toString(36).substr(2, 9)}`;
---

<div class={`interactive-map ${className}`} data-map-id={mapId} data-marker-color={markerColor} style={`height: ${height};`}>
  <!-- Fallback content for SEO - server-rendered -->
  <noscript>
    <div class="map-fallback">
      <p>Kaart centrum: {center.lat.toFixed(4)}, {center.lon.toFixed(4)}</p>
      {markers.length > 0 && (
        <ul>
          {markers.map((marker, index) => (
            <li>
              {marker.number && `${marker.number}. `}
              {marker.name} - {marker.lat.toFixed(4)}, {marker.lon.toFixed(4)}
            </li>
          ))}
        </ul>
      )}
    </div>
  </noscript>
</div>

<script define:vars={{ mapId, center, markers, markerColor }} is:inline>
  (function() {
    // Load Leaflet CSS if not already loaded
    if (!document.querySelector('link[href*="leaflet"]')) {
      const link = document.createElement("link");
      link.rel = "stylesheet";
      link.href = "https://unpkg.com/leaflet@1.9.4/dist/leaflet.css";
      link.integrity = "sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=";
      link.crossOrigin = "";
      document.head.appendChild(link);
    }

    // Shared function to setup map tiles and markers
    function setupMapContent(map, mapContainerElement, mapCenter, mapMarkers, mapMarkerColor) {
      const L = window.L;
      if (!L) return;
      
      // Add OpenStreetMap tiles
      L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
        maxZoom: 19,
      }).addTo(map);

      // Add markers
      mapMarkers.forEach(function(marker, index) {
        try {
          const markerNumber = marker.number !== undefined ? marker.number : index + 1;
          
          const customIcon = L.divIcon({
            className: "custom-numbered-marker",
            html: '<div class="marker-number">' + markerNumber + '</div>',
            iconSize: [30, 30],
            iconAnchor: [15, 30],
          });
          
          const markerElement = L.marker([marker.lat, marker.lon], { icon: customIcon })
            .addTo(map)
            .bindPopup(marker.name);
          
          // Apply background color to the marker container after it's added to the map
          markerElement.on('add', function() {
            const iconElement = this._icon;
            if (iconElement) {
              iconElement.style.backgroundColor = mapMarkerColor;
            }
          });
          
          // Also try immediately in case it's already added
          if (markerElement._icon) {
            markerElement._icon.style.backgroundColor = mapMarkerColor;
          }
        } catch (e) {
          console.error('Error adding marker:', e, marker);
        }
      });

      // Fit bounds to show all markers if there are any
      // Use a delayed approach to ensure map has valid dimensions
      if (mapMarkers.length > 0) {
        // Ensure map has valid size before fitting bounds
        map.invalidateSize();
        
        // Use requestAnimationFrame to ensure the map is fully rendered
        requestAnimationFrame(function() {
          // Double-check map container has valid dimensions
          const container = map.getContainer();
          if (container && container.offsetWidth > 0 && container.offsetHeight > 0) {
            try {
              const bounds = L.latLngBounds(
                mapMarkers.map(function(m) { return [m.lat, m.lon]; })
              );
              map.fitBounds(bounds, { padding: [50, 50] });
            } catch (e) {
              // If fitBounds fails, fall back to setView with the first marker or center
              if (mapMarkers.length > 0) {
                map.setView([mapMarkers[0].lat, mapMarkers[0].lon], mapCenter.zoom);
              } else {
                map.setView([mapCenter.lat, mapCenter.lon], mapCenter.zoom);
              }
            }
          } else {
            // Retry after a short delay if dimensions aren't ready
            setTimeout(function() {
              map.invalidateSize();
              const container = map.getContainer();
              if (container && container.offsetWidth > 0 && container.offsetHeight > 0) {
                try {
                  const bounds = L.latLngBounds(
                    mapMarkers.map(function(m) { return [m.lat, m.lon]; })
                  );
                  map.fitBounds(bounds, { padding: [50, 50] });
                } catch (e) {
                  if (mapMarkers.length > 0) {
                    map.setView([mapMarkers[0].lat, mapMarkers[0].lon], mapCenter.zoom);
                  } else {
                    map.setView([mapCenter.lat, mapCenter.lon], mapCenter.zoom);
                  }
                }
              }
            }, 100);
          }
        });
      }
    }

    function initMap() {
      const L = window.L;
      if (!L) {
        return;
      }

      // Fix for default marker icon path issue
      delete L.Icon.Default.prototype._getIconUrl;
      L.Icon.Default.mergeOptions({
        iconRetinaUrl: "https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/images/marker-icon-2x.png",
        iconUrl: "https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/images/marker-icon.png",
        shadowUrl: "https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/images/marker-shadow.png",
      });

      const mapContainer = document.querySelector(`[data-map-id="${mapId}"]`);
      if (!mapContainer) {
        // Retry after a short delay if element not found
        setTimeout(initMap, 100);
        return;
      }

      // Check if map already initialized
      if (mapContainer._leafletMap) {
        return;
      }

      // Check if container exists and has width (height can be 0 for 100% height containers)
      const hasWidth = mapContainer.offsetWidth > 0;
      const hasHeight = mapContainer.offsetHeight > 0;
      const parent = mapContainer.parentElement;
      const isInModal = parent && (parent.classList.contains('map-modal-body') || parent.closest('.map-modal'));
      
      // Mark as pending if truly hidden (no width)
      // Maps in modals will be initialized when the modal opens via initPendingMaps
      if (!hasWidth) {
        mapContainer.setAttribute("data-map-pending", "true");
        mapContainer.setAttribute("data-map-config", JSON.stringify({ center: center, markers: markers, markerColor: markerColor }));
        return;
      }
      
      // For containers with 100% height or invalid height, ensure they have a minimum height for Leaflet
      // This is especially important when markers are present, as fitBounds requires valid dimensions
      // Skip this check for modals - they'll be handled when the modal opens
      if (!hasHeight && !isInModal) {
        // Set a temporary min-height so Leaflet can initialize
        const originalMinHeight = mapContainer.style.minHeight;
        const computedStyle = window.getComputedStyle(mapContainer);
        const heightValue = computedStyle.height;
        
        // If height is 100% or 0, set a minimum height
        if (heightValue === '0px' || heightValue === 'auto' || heightValue.includes('%')) {
          mapContainer.style.minHeight = '400px';
        }
        
        // Initialize map
        try {
          const map = L.map(mapContainer).setView([center.lat, center.lon], center.zoom);
          mapContainer._leafletMap = map;
          
          // Setup tiles and markers
          setupMapContent(map, mapContainer, center, markers, markerColor);
          
          // Remove min-height after a short delay (map will resize)
          setTimeout(function() {
            mapContainer.style.minHeight = originalMinHeight || '';
            map.invalidateSize();
          }, 200);
        } catch (e) {
          console.error('Error initializing map (min-height path)', mapId, e);
        }
        return;
      }

      // Create map instance (normal case)
      try {
        const map = L.map(mapContainer).setView([center.lat, center.lon], center.zoom);
        
        // Store map instance on container for later access
        mapContainer._leafletMap = map;

        // Setup tiles and markers
        setupMapContent(map, mapContainer, center, markers, markerColor);
      } catch (e) {
        console.error('Error initializing map', mapId, e);
      }
    }

    // Function to initialize pending maps (for maps in hidden containers)
    window.initPendingMaps = function(container) {
      const L = window.L;
      if (!L) {
        return;
      }

      // Find all map containers in the given container (or document)
      const allMapContainers = container ? 
        container.querySelectorAll('[data-map-id]') : 
        document.querySelectorAll('[data-map-id]');
      
      allMapContainers.forEach(function(mapContainer) {
        // Skip if already initialized
        if (mapContainer._leafletMap) {
          return;
        }

        // Check if this is a pending map
        const isPending = mapContainer.getAttribute("data-map-pending") === "true";
        const configStr = mapContainer.getAttribute("data-map-config");
        
        if (isPending && configStr) {
          // This is a pending map with config
          const config = JSON.parse(configStr);
          
          // For modals, initialize even if dimensions aren't ready yet
          const parent = mapContainer.parentElement;
          const isInModal = parent && (parent.classList.contains('map-modal-body') || parent.closest('.map-modal'));
          const isVisible = mapContainer.offsetWidth > 0 && mapContainer.offsetHeight > 0;
          
          if (!isVisible && !isInModal) {
            // Not visible and not in modal, skip for now
            return;
          }

          // Remove pending flag
          mapContainer.removeAttribute("data-map-pending");
          mapContainer.removeAttribute("data-map-config");

          // Fix for default marker icon path issue
          delete L.Icon.Default.prototype._getIconUrl;
          L.Icon.Default.mergeOptions({
            iconRetinaUrl: "https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/images/marker-icon-2x.png",
            iconUrl: "https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/images/marker-icon.png",
            shadowUrl: "https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/images/marker-shadow.png",
          });

          // For modals or containers without height, set a temporary min-height
          if (!isVisible || mapContainer.offsetHeight === 0) {
            const originalMinHeight = mapContainer.style.minHeight;
            mapContainer.style.minHeight = '400px';
            
            try {
              // Create map instance
              const map = L.map(mapContainer).setView([config.center.lat, config.center.lon], config.center.zoom);
              mapContainer._leafletMap = map;

              // Setup tiles and markers using the shared function
              const markerColorValue = config.markerColor || markerColor;
              setupMapContent(map, mapContainer, config.center, config.markers, markerColorValue);
              
              // Remove min-height and invalidate size after a delay
              setTimeout(function() {
                mapContainer.style.minHeight = originalMinHeight || '';
                map.invalidateSize();
              }, 200);
            } catch (e) {
              console.error('Error initializing pending map', e);
              mapContainer.style.minHeight = originalMinHeight || '';
            }
          } else {
            // Normal initialization
            try {
              const map = L.map(mapContainer).setView([config.center.lat, config.center.lon], config.center.zoom);
              mapContainer._leafletMap = map;

              // Setup tiles and markers using the shared function
              const markerColorValue = config.markerColor || markerColor;
              setupMapContent(map, mapContainer, config.center, config.markers, markerColorValue);
              
              // Invalidate size after a short delay to ensure proper rendering
              setTimeout(function() {
                map.invalidateSize();
              }, 100);
            } catch (e) {
              console.error('Error initializing pending map', e);
            }
          }
        }
      });
    };

    // Load Leaflet JS if not already loaded, then initialize
    function tryInitMap() {
      if (window.L) {
        // Leaflet is loaded, initialize map
        initMap();
      } else {
        // Leaflet not loaded yet, wait a bit and retry
        setTimeout(tryInitMap, 50);
      }
    }

    if (window.L) {
      // Leaflet already loaded
      if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", tryInitMap);
      } else {
        tryInitMap();
      }
    } else {
      // Check if Leaflet script is already being loaded
      const existingScript = document.querySelector('script[src*="leaflet"]');
      if (!existingScript) {
        // Load Leaflet JS
        const script = document.createElement("script");
        script.src = "https://unpkg.com/leaflet@1.9.4/dist/leaflet.js";
        script.integrity = "sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=";
        script.crossOrigin = "";
        script.onload = function() {
          if (document.readyState === "loading") {
            document.addEventListener("DOMContentLoaded", tryInitMap);
          } else {
            tryInitMap();
          }
        };
        script.onerror = function() {
          console.error('Failed to load Leaflet library');
        };
        document.head.appendChild(script);
      } else {
        // Script is already being loaded, wait for it
        if (document.readyState === "loading") {
          document.addEventListener("DOMContentLoaded", tryInitMap);
        } else {
          tryInitMap();
        }
      }
    }
  })();
</script>

<style>
  .interactive-map {
    width: 100%;
    border-radius: 12px;
    overflow: hidden;
    background-color: #f0f0f0;
  }

  .map-fallback {
    padding: 2rem;
    text-align: center;
    color: #666;
  }

  .map-fallback ul {
    list-style: none;
    padding: 0;
    margin-top: 1rem;
  }

  .map-fallback li {
    padding: 0.5rem 0;
    border-bottom: 1px solid #ddd;
  }

  /* Custom numbered marker styles */
  :global(.custom-numbered-marker) {
    border: 2px solid white;
    border-radius: 4px;
    width: 30px;
    height: 30px;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
    padding: 0;
    margin: 0;
  }

  :global(.marker-number) {
    color: white;
    font-weight: bold;
    font-size: 14px;
    line-height: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    width: 100%;
    height: 100%;
    margin: 0;
    padding: 0;
    text-align: center;
    background-color: transparent;
  }

  /* Leaflet popup customization */
  :global(.leaflet-popup-content-wrapper) {
    border-radius: 8px;
  }

  :global(.leaflet-popup-content) {
    margin: 12px 16px;
    font-size: 14px;
  }
</style>

